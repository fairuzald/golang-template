name: üöÄ Production CI/CD Pipeline

env:
  GO_VERSION: '1.21'
  FIREBASE_PROJECT_ID: ${{ secrets.FIREBASE_PROJECT_ID }}
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
  APP_ENV: production

on:
  push:
    branches: [main, master]
    paths-ignore:
      - '**.md'
      - '.gitignore'
      - 'LICENSE'
      - 'docs/**'
      - '**.txt'
  workflow_dispatch:
    inputs:
      deploy_notes:
        description: 'Deployment notes'
        required: false
        default: 'Manual production deployment'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: read
  deployments: write
  issues: write

jobs:
  deploy:
    name: üöÄ Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment:
      name: production
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: üîç Get Commit Information
        id: get-commit-message
        run: |
          COMMIT_MSG=$(git log -1 --pretty=%B)
          echo "message<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_MSG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: üîç Get Deploy Notes
        id: get-deploy-notes
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "notes=${{ github.event.inputs.deploy_notes }}" >> $GITHUB_OUTPUT
          else
            echo "notes=Automated production deployment" >> $GITHUB_OUTPUT
          fi

      - name: üîß Setup Go Environment
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: üèóÔ∏è Build Main API Package
        run: |
          mkdir -p build
          go build -v -ldflags="-s -w" -o build/api ./cmd/api/main.go

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: üõ†Ô∏è Install Vercel CLI
        run: npm install -g vercel@latest

      - name: üöÄ Deploy to Vercel (Production)
        id: deploy
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
        run: |
          # Create a simplified deployment structure
          echo '{
            "name": "skillup-api",
            "version": "1.0.0",
            "private": true
          }' > package.json

          # Deploy directly using vercel CLI
          echo "Deploying to Vercel"
          DEPLOYMENT_URL=$(vercel --prod --yes --token "${{ secrets.VERCEL_TOKEN }}" \
            --scope "${{ secrets.VERCEL_ORG_ID }}" \
            --env APP_ENV=production \
            --env FIREBASE_PROJECT_ID="${{ secrets.FIREBASE_PROJECT_ID }}" \
            --env FIREBASE_SERVICE_ACCOUNT="${{ secrets.FIREBASE_SERVICE_ACCOUNT }}")

          echo "Deployment URL: $DEPLOYMENT_URL"
          echo "url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo "DEPLOYMENT_URL=$DEPLOYMENT_URL" >> $GITHUB_ENV

      - name: üè∑Ô∏è Create Deployment Tag
        uses: actions/github-script@v7
        with:
          script: |
            const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
            const tagName = `production-${date}-${context.sha.substring(0, 7)}`;

            try {
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/tags/${tagName}`,
                sha: context.sha
              });

              console.log(`Created tag: ${tagName}`);
            } catch (error) {
              console.log(`Failed to create tag: ${error.message}`);
            }

      - name: üîç Verify Deployment Health
        if: success()
        run: |
          HEALTH_URL="${{ steps.deploy.outputs.url }}/api/health"
          echo "Checking deployment health at: $HEALTH_URL"

          # Wait a bit for the deployment to fully initialize
          sleep 30

          # Check health endpoint
          RESPONSE=$(curl -s -o health_response.json -w "%{http_code}" "$HEALTH_URL" || echo "000")

          if [ "$RESPONSE" != "200" ]; then
            echo "::warning::Health check returned status: $RESPONSE"
            cat health_response.json || echo "No response body"
            # Don't fail the workflow on health check issues
          else
            echo "Health check succeeded!"
            cat health_response.json
          fi

      - name: üìù Update Production Status
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const formatDate = () => {
              return new Date().toLocaleString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: 'numeric',
                minute: 'numeric',
                hour12: false
              });
            };

            const getBuildDuration = () => {
              try {
                const startTime = new Date(context.payload.repository.updated_at);
                const endTime = new Date();
                return Math.round((endTime - startTime) / 1000 / 60);
              } catch (error) {
                return 0; // Default if can't calculate
              }
            };

            const deploymentEntry = {
              date: formatDate(),
              commit: context.sha.slice(0, 7),
              message: ${{ toJSON(steps.get-commit-message.outputs.message) }},
              notes: ${{ toJSON(steps.get-deploy-notes.outputs.notes) }},
              status: '‚úÖ',
              url: process.env.DEPLOYMENT_URL || 'unknown',
              duration: getBuildDuration()
            };

            const issueTitle = 'üì¢ Production Deployment History';

            try {
              const issues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: ['production-deployments']
              });

              const existingIssue = issues.data.find(issue =>
                issue.title === issueTitle
              );

              let previousDeployments = [];
              if (existingIssue) {
                const deploymentTableRegex = /\| (.*?) \| \[(.*?)\].*? \| (.*?) \| (.*?) \| (.*?) \| (.*?) \|/g;
                let match;
                const existingContent = existingIssue.body;

                while ((match = deploymentTableRegex.exec(existingContent)) !== null) {
                  previousDeployments.push({
                    date: match[1],
                    commit: match[2],
                    message: match[3],
                    notes: match[4],
                    status: match[5],
                    url: match[6]
                  });
                }

                // Keep only last 9 previous deployments
                previousDeployments = previousDeployments.slice(0, 9);
              }

              const allDeployments = [deploymentEntry, ...previousDeployments];

              const deploymentHistory = `
              # üì¢ Production Deployment History

              ## üìå Latest Deployment
              - **Status:** ‚úÖ Success
              - **Deployment URL:** [${deploymentEntry.url}](${deploymentEntry.url})
              - **Commit:** [\`${deploymentEntry.commit}\`](${context.payload.repository.html_url}/commit/${context.sha})
              - **Time:** ${deploymentEntry.date}
              - **Duration:** ${deploymentEntry.duration} minutes
              - **Notes:** ${deploymentEntry.notes}

              ## üìä Deployment Log
              | Date | Commit | Changes | Notes | Status | URL |
              |------|--------|---------|-------|--------|-----|
              ${allDeployments.map(d =>
                `| ${d.date} | [\`${d.commit}\`](${context.payload.repository.html_url}/commit/${d.commit}) | ${d.message} | ${d.notes || '-'} | ${d.status} | [View](${d.url}) |`
              ).join('\n')}

              ## üîÑ Environment Information
              - **Go Version:** ${process.env.GO_VERSION}
              - **Environment:** Production
              - **Project:** SkillUp API

              > üïí Last Updated: ${formatDate()}
              `;

              if (existingIssue) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existingIssue.number,
                  body: deploymentHistory
                });
              } else {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: issueTitle,
                  body: deploymentHistory,
                  labels: ['production-deployments']
                });
              }
            } catch (error) {
              console.log(`Error updating deployment history: ${error.message}`);
            }

      - name: üìù Create Production Failure Alert
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const errorNote = `
            # üö® Production Deployment Failure

            ## ‚ùå Critical Alert
            Production deployment has failed and requires immediate attention.

            ### üìå Failure Details
            - **Environment:** Production
            - **Commit:** [\`${context.sha.slice(0, 7)}\`](${context.payload.repository.html_url}/commit/${context.sha})
            - **Time:** ${new Date().toLocaleString()}
            - **Action Run:** [View Logs](${context.payload.repository.html_url}/actions/runs/${context.runId})

            ### üîç Immediate Actions Required
            1. Review the [deployment logs](${context.payload.repository.html_url}/actions/runs/${context.runId})
            2. Check environment variables and secrets
            3. Verify Vercel configuration
            4. Review recent changes in the main branch

            ### ‚ö° Current Status
            - Previous production deployment remains active
            - New changes have not been deployed
            - Manual intervention required

            > ‚ö†Ô∏è This issue requires immediate attention from the development team.
            `;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üö® URGENT: Production Deployment Failure - ${new Date().toLocaleString()}`,
              body: errorNote,
              labels: ['deployment-failure', 'high-priority', 'production']
            });
