name: üöÄ Production CI/CD Pipeline

env:
  GO_VERSION: '1.21'
  FIREBASE_PROJECT_ID: ${{ secrets.FIREBASE_PROJECT_ID }}
  FIREBASE_SERVICE_ACCOUNT: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
  APP_ENV: production

on:
  push:
    branches: [main, master]
    paths-ignore:
      - '**.md'
      - '.gitignore'
      - 'LICENSE'
      - 'docs/**'
      - '**.txt'
  workflow_dispatch:
    inputs:
      deploy_notes:
        description: 'Deployment notes'
        required: false
        default: 'Manual production deployment'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: read
  deployments: write
  issues: write

jobs:
  initialize:
    name: üéØ Initialize Production Build
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      commit-message: ${{ steps.get-commit-message.outputs.message }}
      deploy-notes: ${{ steps.get-deploy-notes.outputs.notes }}

    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: üîç Get Commit Information
        id: get-commit-message
        run: |
          COMMIT_MSG=$(git log -1 --pretty=%B)
          echo "message<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_MSG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: üîç Get Deploy Notes
        id: get-deploy-notes
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "notes=${{ github.event.inputs.deploy_notes }}" >> $GITHUB_OUTPUT
          else
            echo "notes=Automated production deployment" >> $GITHUB_OUTPUT
          fi

      - name: üîß Setup Go Environment
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

  build:
    name: üèóÔ∏è Production Build
    needs: [initialize]
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4

      - name: üîß Setup Go Environment
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      # Removed the Swagger docs generation step as it was causing issues

      - name: üèóÔ∏è Create Output Directory
        run: |
          mkdir -p build

      - name: üèóÔ∏è Build Main API Package
        run: |
          go build -v -ldflags="-s -w" -o build/api ./cmd/api

      - name: üì¶ Prepare Production Package
        run: |
          mkdir -p deploy
          mkdir -p deploy/build
          cp -r build/api deploy/build/
          cp -r public deploy/

          # Create docs directory if it doesn't exist (for Vercel)
          mkdir -p deploy/docs/swagger
          if [ -d "docs/swagger" ]; then
            cp -r docs/swagger deploy/docs/
          fi

          cp vercel.json deploy/

  deploy:
    name: üöÄ Deploy to Production
    needs: [initialize, build]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment:
      name: production
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4

      - name: üì¶ Copy Build Artifacts
        run: |
          mkdir -p deploy/build
          mkdir -p deploy/public
          mkdir -p deploy/docs/swagger
          cp -r public/* deploy/public/ || true
          cp vercel.json deploy/

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: üõ†Ô∏è Install Vercel CLI
        run: npm install -g vercel@latest


      - name: üöÄ Deploy to Vercel (Production)
        id: deploy
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
        run: |
          cd deploy

          # Debug the environment
          echo "Checking directory contents:"
          ls -la

          # Make sure token is available (masked in logs)
          if [ -z "$VERCEL_TOKEN" ]; then
            echo "::error::VERCEL_TOKEN is not set"
            exit 1
          else
            echo "VERCEL_TOKEN is set"
          fi

          # Create production deployment with explicit token
          DEPLOYMENT_URL=$(vercel deploy --prod --token="$VERCEL_TOKEN" \
            --env APP_ENV=production \
            --env FIREBASE_PROJECT_ID=${{ secrets.FIREBASE_PROJECT_ID }} \
            --env FIREBASE_SERVICE_ACCOUNT=${{ secrets.FIREBASE_SERVICE_ACCOUNT }})

          echo "url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo "DEPLOYMENT_URL=$DEPLOYMENT_URL" >> $GITHUB_ENV

      - name: üè∑Ô∏è Create Deployment Tag
        uses: actions/github-script@v7
        with:
          script: |
            const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
            const tagName = `production-${date}-${context.sha.substring(0, 7)}`;

            try {
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/tags/${tagName}`,
                sha: context.sha
              });

              console.log(`Created tag: ${tagName}`);
            } catch (error) {
              console.log(`Failed to create tag: ${error.message}`);
            }

  monitor:
    name: üìä Post-Deployment Monitoring
    needs: [initialize, deploy]
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: success()

    steps:
      - name: üîç Verify Deployment Health
        run: |
          HEALTH_URL="${{ needs.deploy.outputs.url }}/api/health"
          echo "Checking deployment health at: $HEALTH_URL"

          # Wait a bit for the deployment to fully initialize
          sleep 30

          # Check health endpoint
          RESPONSE=$(curl -s -o health_response.json -w "%{http_code}" "$HEALTH_URL" || echo "000")

          if [ "$RESPONSE" != "200" ]; then
            echo "::warning::Health check returned status: $RESPONSE"
            cat health_response.json || echo "No response body"
            # Don't fail the workflow on health check issues
          else
            echo "Health check succeeded!"
            cat health_response.json
          fi

      - name: üìù Update Production Status
        uses: actions/github-script@v7
        with:
          script: |
            const formatDate = () => {
              return new Date().toLocaleString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: 'numeric',
                minute: 'numeric',
                hour12: false
              });
            };

            const getBuildDuration = () => {
              try {
                const startTime = new Date(context.payload.repository.updated_at);
                const endTime = new Date();
                return Math.round((endTime - startTime) / 1000 / 60);
              } catch (error) {
                return 0; // Default if can't calculate
              }
            };

            const deploymentEntry = {
              date: formatDate(),
              commit: context.sha.slice(0, 7),
              message: ${{ toJSON(needs.initialize.outputs.commit-message) }},
              notes: ${{ toJSON(needs.initialize.outputs.deploy-notes) }},
              status: '‚úÖ',
              url: process.env.DEPLOYMENT_URL || 'unknown',
              duration: getBuildDuration()
            };

            const issueTitle = 'üì¢ Production Deployment History';

            try {
              const issues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: ['production-deployments']
              });

              const existingIssue = issues.data.find(issue =>
                issue.title === issueTitle
              );

              let previousDeployments = [];
              if (existingIssue) {
                const deploymentTableRegex = /\| (.*?) \| \[(.*?)\].*? \| (.*?) \| (.*?) \| (.*?) \| (.*?) \|/g;
                let match;
                const existingContent = existingIssue.body;

                while ((match = deploymentTableRegex.exec(existingContent)) !== null) {
                  previousDeployments.push({
                    date: match[1],
                    commit: match[2],
                    message: match[3],
                    notes: match[4],
                    status: match[5],
                    url: match[6]
                  });
                }

                // Keep only last 9 previous deployments
                previousDeployments = previousDeployments.slice(0, 9);
              }

              const allDeployments = [deploymentEntry, ...previousDeployments];

              const deploymentHistory = `
              # üì¢ Production Deployment History

              ## üìå Latest Deployment
              - **Status:** ‚úÖ Success
              - **Deployment URL:** [${deploymentEntry.url}](${deploymentEntry.url})
              - **Commit:** [\`${deploymentEntry.commit}\`](${context.payload.repository.html_url}/commit/${context.sha})
              - **Time:** ${deploymentEntry.date}
              - **Duration:** ${deploymentEntry.duration} minutes
              - **Notes:** ${deploymentEntry.notes}

              ## üìä Deployment Log
              | Date | Commit | Changes | Notes | Status | URL |
              |------|--------|---------|-------|--------|-----|
              ${allDeployments.map(d =>
                `| ${d.date} | [\`${d.commit}\`](${context.payload.repository.html_url}/commit/${d.commit}) | ${d.message} | ${d.notes || '-'} | ${d.status} | [View](${d.url}) |`
              ).join('\n')}

              ## üîÑ Environment Information
              - **Go Version:** ${process.env.GO_VERSION}
              - **Environment:** Production
              - **Project:** SkillUp API

              > üïí Last Updated: ${formatDate()}
              `;

              if (existingIssue) {
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existingIssue.number,
                  body: deploymentHistory
                });
              } else {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: issueTitle,
                  body: deploymentHistory,
                  labels: ['production-deployments']
                });
              }
            } catch (error) {
              console.log(`Error updating deployment history: ${error.message}`);
            }

  error_handling:
    name: ‚ö†Ô∏è Error Handling
    needs: [initialize, deploy]
    runs-on: ubuntu-latest
    if: failure() && needs.deploy.result == 'failure'
    steps:
      - name: üìù Create Production Failure Alert
        uses: actions/github-script@v7
        with:
          script: |
            const errorNote = `
            # üö® Production Deployment Failure

            ## ‚ùå Critical Alert
            Production deployment has failed and requires immediate attention.

            ### üìå Failure Details
            - **Environment:** Production
            - **Commit:** [\`${context.sha.slice(0, 7)}\`](${context.payload.repository.html_url}/commit/${context.sha})
            - **Time:** ${new Date().toLocaleString()}
            - **Action Run:** [View Logs](${context.payload.repository.html_url}/actions/runs/${context.runId})

            ### üîç Immediate Actions Required
            1. Review the [deployment logs](${context.payload.repository.html_url}/actions/runs/${context.runId})
            2. Check environment variables and secrets
            3. Verify Vercel configuration
            4. Review recent changes in the main branch

            ### ‚ö° Current Status
            - Previous production deployment remains active
            - New changes have not been deployed
            - Manual intervention required

            > ‚ö†Ô∏è This issue requires immediate attention from the development team.
            `;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üö® URGENT: Production Deployment Failure - ${new Date().toLocaleString()}`,
              body: errorNote,
              labels: ['deployment-failure', 'high-priority', 'production']
            });
